<?php

/*
 * This file is part of blomstra/digest.
 *
 * Copyright (c) 2022 Team Blomstra.
 *
 * For the full copyright and license information, please view the LICENSE.md
 * file that was distributed with this source code.
 */

namespace Blomstra\Digest\Batch;

use Blomstra\Digest\Notification\SaveEmailForDigestJob;
use Flarum\Notification\Blueprint\BlueprintInterface;
use Flarum\Notification\Job\SendEmailNotificationJob;
use Flarum\Notification\MailableInterface;
use Flarum\Settings\SettingsRepositoryInterface;
use Flarum\User\User;
use Illuminate\Contracts\Container\Container;
use Illuminate\Contracts\Queue\Queue;
use Illuminate\Queue\SyncQueue;
use Illuminate\Support\Arr;
use Illuminate\Support\Str;

/**
 * Prepares a batch to group blueprints generated during a same request lifecycle
 * Batches are required because some blueprints will be generated by queued jobs.
 */
class BatchJobAggregator
{
    // Since multiple jobs may execute inside one another, we need to keep track of the nested stack
    protected $workerBatchIdStack = [];
    // Keep the current active batch ID for easy access
    protected $workerBatchId = null;

    protected $aggregatingNewNotifications = false;

    /**
     * Jobs that are processed synchronously by Flarum will have their generated blueprints processed through SaveEmailForDigestJob jobs
     * We save them here for later because they will require a batch ID that's only known at the end of the lifecycle.
     *
     * @var SaveEmailForDigestJob[]
     */
    protected $syncJobs = [];

    protected $batchId;

    protected $asyncJobsWereBatched = false;

    protected $queue;
    protected $sync;
    protected $batchRepository;
    protected $settings;

    public function __construct(Container $container, Queue $queue, SyncQueue $sync, DigestBatchRepository $batchRepository, SettingsRepositoryInterface $settings)
    {
        $this->queue = $queue;
        $this->sync = $sync;
        $this->sync->setContainer($container);
        $this->batchRepository = $batchRepository;
        $this->settings = $settings;
    }

    protected function batchId(): string
    {
        if (!$this->batchId) {
            $this->batchId = (string) Str::orderedUuid();
        }

        return $this->batchId;
    }

    protected function singleDigestEnabled()
    {
        return $this->settings->get('blomstra-digest.singleDigest');
    }

    /**
     * This tells the batcher to start bundling jobs sent during a single request lifecycle.
     */
    public function startAggregating(): void
    {
        // Doing the check here is the quickest option, as it will apply to both pushSync and attachAsync
        // This also allows the same code to handle the no-single-digest situation and the fallback to non-single-digest-contexts in pushSync without complex if/else
        if (!$this->singleDigestEnabled()) {
            return;
        }

        $this->aggregatingNewNotifications = true;
    }

    /**
     * @param BlueprintInterface&MailableInterface $blueprint
     * @param User                                 $recipient
     */
    public function pushSyncBlueprint(BlueprintInterface $blueprint, User $recipient): void
    {
        // If a job is currently being processed by the worker, it takes priority over everything else
        // In that case we immediately persist the blueprint to the database with the current batch ID
        if ($this->workerBatchId) {
            $this->sync->push(new SaveEmailForDigestJob($blueprint, $recipient, $this->workerBatchId));

            return;
        }

        // If this is a regular blueprint sent synchronously from the root process, and we are currently aggregating, add to the batch
        // This is also where regular queuable jobs end up on the sync queue because they never trigger the JobQueued event that would push them to the attachAsync method
        if ($this->aggregatingNewNotifications) {
            $this->syncJobs[] = new SaveEmailForDigestJob($blueprint, $recipient);

            return;
        }

        // If the batcher is not supported in the current context, always send regular mails
        // This will happen if a command line command sends a notification for example
        // This code is also called when the single digest feature is disabled
        $this->queue->push(new SendEmailNotificationJob($blueprint, $recipient));
    }

    public function attachAsyncJob(string $jobId)
    {
        if ($this->aggregatingNewNotifications) {
            $this->batchRepository->addJob($jobId, $this->batchId());

            $this->asyncJobsWereBatched = true;
        }
    }

    public function stopAggregating(): void
    {
        // If there were no notifications during this request, all good, we can skip
        if (count($this->syncJobs) === 0 && !$this->asyncJobsWereBatched) {
            return;
        }

        // Force these to run synchronously because we won't be watching those for completion in the batch system
        foreach ($this->syncJobs as $syncJob) {
            $syncJob->setBatch($this->batchId());
            $this->sync->push($syncJob);
        }

        // If there were no async jobs, we can queue the batch job immediately
        // Otherwise it'll be queued automatically when all jobs in the batch have finished processing
        if (!$this->asyncJobsWereBatched) {
            $this->queue->push(new SendBatch($this->batchId()));
        }
    }

    public function workerIsAboutToProcessJob(string $jobId): void
    {
        if ($this->singleDigestEnabled()) {
            // Save the currently processed batch ID to make it available in pushSync
            $batchId = $this->batchRepository->getJobBatch($jobId);

            // Set the new batch ID as the current one if set. This ignores nested jobs that are unrelated to this feature
            if ($batchId) {
                $this->workerBatchId = $batchId;
            }

            // Add the ID to the stack, even if it's null
            $this->workerBatchIdStack[] = $batchId;
        }
    }

    public function workerFinishedProcessingJob(string $jobId): void
    {
        if (!$this->singleDigestEnabled()) {
            return;
        }

        // Access and remove the last ID off the stack
        $batchId = array_pop($this->workerBatchIdStack);

        // To save up on database requests during jobs that aren't related to notifications
        // We check if the job previously existed in a batch when it started processing
        if (!$batchId) {
            return;
        }

        $this->batchRepository->removeJob($jobId);

        // If this was the last job in the batch, time to queue the sending of the batch
        if (!$this->batchRepository->hasJobsLeft($batchId)) {
            $this->queue->push(new SendBatch($batchId));
        }

        // There generally won't be multiple levels in the stack with a batch ID, but we never know...
        // So we'll retrieve the next active stack ID here and default to null if there are no levels left in the stack
        $this->workerBatchId = Arr::last($this->workerBatchIdStack);
    }
}
